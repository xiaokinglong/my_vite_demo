"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const defaultsDeep = require("lodash.defaultsdeep");
const parser_1 = require("./parser");
const assembler_1 = require("./assembler");
const template_compiler_1 = require("./template-compiler");
const processor_1 = require("./processor");
const style_compiler_1 = require("./style-compiler");
const utils_1 = require("./utils");
const defaultOptions = require("./default-options");
function compile(content, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        options = normalizeOptions(options);
        const components = parseComponent(content, options);
        const promises = [];
        if (components.script) {
            promises[0] = processor_1.proc(components.script, options.processOptions);
        }
        if (components.template) {
            promises[1] = processor_1.proc(components.template, options.processOptions, getTemplateCompiler(options));
        }
        const styleCompiler = getStyleCompiler(style_compiler_1.compileStyle, options);
        promises[2] = Promise.all(components.styles.map((style) => {
            return processor_1.proc(style, options.processOptions, styleCompiler);
        }));
        promises[3] = Promise.all(components.customBlocks.map((block) => {
            return processor_1.proc(block, options.processOptions);
        }));
        const [script, template, styles, customBlocks] = yield Promise.all(promises);
        return generateResult({ script, template, styles, customBlocks }, options);
    });
}
exports.compile = compile;
function compileSync(content, options = {}) {
    options = normalizeOptions(options);
    const components = parseComponent(content, options);
    let script;
    if (components.script) {
        script = processor_1.procSync(components.script, options.processOptions);
    }
    let template;
    if (components.template) {
        template = processor_1.procSync(components.template, options.processOptions, getTemplateCompiler(options));
    }
    const styleCompiler = getStyleCompiler(style_compiler_1.compileStyleSync, options);
    const styles = components.styles.map((style) => {
        return processor_1.procSync(style, options.processOptions, styleCompiler);
    });
    const customBlocks = components.customBlocks.map((block) => {
        return processor_1.procSync(block, options.processOptions);
    });
    return generateResult({ script, template, styles, customBlocks }, options);
}
exports.compileSync = compileSync;
function normalizeOptions(options) {
    options = defaultsDeep({}, options, defaultOptions[options.mode || 'production']);
    if (options.scopeId == null) {
        options.scopeId = utils_1.genId(options.filename);
    }
    return options;
}
function parseComponent(content, options) {
    return parser_1.default(content, Object.assign({ filename: options.filename, sourceMaps: options.sourceMaps, sourceRoot: options.sourceRoot }, options.parseOptions));
}
function getTemplateCompiler(options) {
    return (item) => template_compiler_1.default(item, Object.assign({}, options.templateOptions, { ssrOptimize: options.ssrOptimize }));
}
function getStyleCompiler(compile, options) {
    return (item) => compile(item, Object.assign({ scopeId: options.scopeId, filename: options.filename, sourceMaps: options.sourceMaps, sourceRoot: options.sourceRoot }, options.styleOptions));
}
function generateResult(components, options) {
    const assembleResult = assembler_1.default(components, Object.assign({ styleSourceMaps: options.sourceMaps, ssrOptimize: options.ssrOptimize, scopeId: options.scopeId, filename: options.filename, sourceMaps: options.sourceMaps, sourceRoot: options.sourceRoot }, options.assembleOptions));
    const result = Object.assign({}, assembleResult, { scopeId: options.scopeId });
    if (components.template) {
        result.tips = components.template.tips;
        result.errors = components.template.errors;
        result.functional = !!components.template.functional;
    }
    return result;
}

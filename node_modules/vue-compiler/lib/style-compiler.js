"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const scoped_1 = require("@vue/component-compiler-utils/dist/stylePlugins/scoped");
const source_map_1 = require("source-map");
const postcss = require("postcss");
const postcssModules = require('postcss-modules');
const postcssComposition = require('postcss-plugin-composition');
function compileStyle(item, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const block = Object.assign({}, item, { scoped: !!item.attrs.scoped });
        return normalizeResult(block, options, yield compile(block, options));
    });
}
exports.compileStyle = compileStyle;
function compileStyleSync(item, options) {
    const block = Object.assign({}, item, { scoped: !!item.attrs.scoped });
    return normalizeResult(block, options, compile(block, options));
}
exports.compileStyleSync = compileStyleSync;
function compile(block, options) {
    if (block.src) {
        return;
    }
    const plugins = options.postcssPlugins.slice();
    if (block.attrs.module) {
        let name = '$style';
        if (block.attrs.module !== true) {
            name = block.attrs.module;
        }
        plugins.push(postcssComposition([
            postcssModules(Object.assign({ getJSON(fileName, mapping) {
                    block.cssModules = { name, mapping };
                } }, options.postcssModules)),
        ]));
    }
    if (block.scoped) {
        plugins.push(scoped_1.default(options.scopeId));
    }
    if (!plugins.length) {
        return;
    }
    const postcssOptions = { from: options.filename, to: options.filename };
    if (options.sourceMaps) {
        const inputSourceMap = block.sourceNode.toStringWithSourceMap({ file: options.filename, sourceRoot: options.sourceRoot }).map;
        postcssOptions.map = { inline: false, annotation: false, prev: inputSourceMap.toJSON() };
    }
    return postcss(plugins).process(block.sourceNode.toString(), postcssOptions);
}
function normalizeResult(block, options, result) {
    if (!result) {
        return block;
    }
    const { css, map } = result;
    if (map) {
        block.sourceNode = source_map_1.SourceNode.fromStringWithSourceMap(css, new source_map_1.SourceMapConsumer(map.toJSON()));
    }
    else {
        block.sourceNode = new source_map_1.SourceNode(null, null, options.filename, css);
    }
    return block;
}
